---
title: "Literate Programming..."
author: "Ganesh Krishnan"
topic: "01"
layout: post
root: ../../../
---

Literate programming: a good level of commenting and adopting good code writing practice that helps us get by the ever-complex world of code jargon in a simplistic manner and enhancing our comprehension of code at hand. Swimming through complex programs and understanding each chunk of it is very difficult, especially if there is no or minimal explanation provided for it. There lies the cause for the development of such a programming methodology, with a range of positive effects.

Time saving comes from debugging, if you understand the program better you can debug faster. Although putting in lines and details for each chunk looks like a cumbersome aspect, but as Donald knuth suggests breaking down the code into chunks and explaining them effectively is a good approach in the long run as it allows our mind to think in a more natural manner and logically filter out errors during a debugging process.

A new code always seems like magic incantation, because to run a code without knowing what it is, is like driving your car in a snow storm without a GPS. You have no clue what to expect from each segment, even if you are aware of the goal. 

Accuracy lies in being detail oriented: Reading a code meant for the machine and without proper explanations, from scratch, is a painstaking and cumbersome process, especially if it is someone elseâ€™s code. There is a high chance that we miss out on nitty gritties, and small details which we are prone to skip through in our quest to understand the whole program.

A well-structured well commented code eliminates this possibility, allowing us to understand and appreciate the small nuances and small artistic/ ingenious findings of the original programmer. This helps us learn in-depth, and lets us incorporate those small ingenious tricks to any future additions / versions of the code.

For most people involved in mathematical sciences, order of presentation becomes very important especially when the complexity of the mathematical model that you are trying to program is high. Literate programming allows us to make the program as readable as the algorithm itself.

Longevity of a code, prevents repetition, and helps reallocation of programmer skill and time into developing and adding to the existing code. Donald Knuth makes a very good point, about focussing more on making humans understand what we want the computer to do.

Elaborating on this, We can look at the whole art of computer programming and compare it with the art of painting. While painting, the motive lies first ito make your imagination be spoken by your brush strokes and get painted onto the canvas. This is the most important and requires a lot of skill. Yet, the part of appreciation does not come if the public is not able to comprehend what the painter is trying to express. It takes the painter, a varying level of skill to actually garner the interest of the public, even if it understands what art is overall. The painter, has to first and foremost, intrigue the reviewing public then show what he means by at least enough dots so that the public can connect them and have a complete and utter understanding of the piece of art that he has comeup with.

Computer programming is similar. Computer is like a single source, that we want to program to do a certain task, and all codes however written and by whoever must have the same meaning for the computer to perform a certain task in hand. Successfully making the computer do its task, is like making a painting but without those imaginary dots, that the reviewing public connects to understand the true meaning of the painting. An understanding and appreciation of the program can only be there if there are enough comments in the code which are like those imaginary dots of the painting. The comments help us to understand and connect each and every level of the ingenious work of the original programmer, and truly understand what he did and how he did it.

The Dilemma of the open Source world: We all love this world. to be able to use codes, perform, contribute and develop with freedom. But there needs to be order in such a world where you can sustain and flourish along with your compatriots and keep contributing effectively and uniquely. Without order we all fall into the chaos of having to develop everything from scratch only to find that we could have done better only if we understood those super-efficient codes out there.

I have been a part of such codes, writing them and also struggled hard to keep pace with them because of a lack of clarity.  I would use literate programming in a such a way that it gives the reader a sense of understanding but keeps pace with my code writing speed. I feel logical flow structures is an essential to most codes, which gives a brief overview of what to expect and how to expect it in the code.  

As suggested by Donald knuth, to accept literate programming is to accept a different manner of programming. I feel as he does that it starts not only from the commenting part but from the coding itself. Structuring the code in a manner that there is a logical and understandable hierarchical sequence is essential, as is, the bare minimum of naming variables in a lucid manner so as to represent what the variable actually stand for.

Incorporating template style writing wherein we can automate and simplify most of our tasks, is one way to go about adopting literate programming. A set of tools that work well together and can plug and play and come up with a nice presentation in the end, would be neat solution. The world of Tex with Latex and Rmarkdown (especially for R users: which I am) being a good example of whats out there, as it enables us to achieve a complex mixture of writing, structure and code development. The code based structure neatly identifies how to arrange our code development along with the explanations. 

Adaptation comes from a conscious effort and with an understanding of why the change is being made. After having understood the relevance, I would love to adapt this simple yet important change so that I can contribute to the development of not only good programs but also for continuity to prevail in my codes. 

